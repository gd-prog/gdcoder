N Integers containing only 1,2&3

Problem Description
Given an integer, A. Find and Return first positive A integers in ascending order containing only digits 1, 2, and 3.
NOTE: All the A integers will fit in 32-bit integers.


Problem Constraints
1 <= A <= 29500


Input Format
The only argument given is integer A.


Output Format
Return an integer array denoting the first positive A integers in ascending order containing only digits 1, 2 and 3.


Example Input
Input 1:
 A = 3
Input 2:
 A = 7


Example Output
Output 1:
 [1, 2, 3]
Output 2:
 [1, 2, 3, 11, 12, 13, 21]


Example Explanation
Explanation 1:
 Output denotes the first 3 integers that contains only digits 1, 2 and 3.
Explanation 2:
 Output denotes the first 7 integers that contains only digits 1, 2 and 3.


Java

public class Solution {
    public ArrayList<Integer> solve(int A) {
        Queue<String> que = new LinkedList<>(); // Initialize a queue to store strings representing the numbers to be generated.
        que.add("1");
        que.add("2");
        que.add("3");
        ArrayList<Integer> ans = new ArrayList<>(); // Create an ArrayList to store the final result.
        for (int i = 1; i <= A; i++) {
            String f = que.peek(); // Get the first element from the queue.
            ans.add(Integer.parseInt(que.peek())); // Add the first element (as an integer) to the ans list.
            que.poll(); // Remove the first element from the queue.
            que.add(f + "1"); // Add a new string formed by appending "1" to the previous element.
            que.add(f + "2"); // Add a new string formed by appending "2" to the previous element.
            que.add(f + "3"); // Add a new string formed by appending "3" to the previous element.
        }
        return ans; // Return the list containing the generated numbers.
    }
}


Python

from collections import deque
class Solution:
    def solve(self, A):
        que = deque(["1", "2", "3"])  # Initialize a queue to store strings representing the numbers to be generated.
        ans = []  # Create an ArrayList to store the final result.
        for i in range(1, A + 1):
            f = que[0]  # Get the first element from the queue.
            ans.append(int(que[0]))  # Add the first element (as an integer) to the ans list.
            que.popleft()  # Remove the first element from the queue.
            que.append(f + "1")  # Add a new string formed by appending "1" to the previous element.
            que.append(f + "2")  # Add a new string formed by appending "2" to the previous element.
            que.append(f + "3")  # Add a new string formed by appending "3" to the previous element.
        return ans  # Return the list containing the generated numbers.


Time Complexity:
	• Outer loop: Iterates A times, where A is the input integer. This takes O(A) time.
	• Inner operations: Within the loop, operations like accessing the first element of the deque, appending new elements, and removing the first element are constant-time operations (O(1)).
Therefore, the overall time complexity of the solve function is O(A).
Space Complexity:
	• Deque: The que deque stores a variable number of strings. In the worst case, the number of elements in the deque can grow exponentially with the value of A. However, the exact growth rate depends on the specific values of A and the pattern of generated numbers.
	• List: The ans list stores A integers, so its space complexity is O(A).
Therefore, the overall space complexity of the solve function is O(A) in terms of the list ans, but the space usage of the que deque can be more complex and depends on the specific input value A. In the worst case, it might grow exponentially with A.

