/*

Flipkarts challenge in effective inventory management

In the recent expansion into grocery delivery, Flipkart faces a crucial challenge in effective inventory management. Each grocery item on the platform carries its own expiration date and profit margin, represented by two arrays, A and B of size N. A[i] denotes the time left before expiration date for the ith item, and B[i] denotes profit margin for the ith item. To mitigate potential losses due to expiring items, Flipkart is seeking a strategic solution.

The objective is to identify a method to strategically buy certain items, ensuring they are sold before their expiration date, thereby maximizing overall profit. Can you assist Flipkart in developing an innovative approach to optimize their grocery inventory and enhance profitability?

Your task is to find the maximum profit one can earn by buying groceries considering that you can only buy one grocery item at a time.

NOTE:

You can assume that it takes 1 minute to buy a grocery item, so you can only buy the ith grocery item when the current time <= A[i] - 1.
You can start buying from day = 0.
Return your answer modulo 109 + 7.


Problem Constraints
1 <= N <= 105
1 <= A[i] <= 109
0 <= B[i] <= 109



Input Format
The first argument is an integer array A represents the deadline for buying the grocery items.
The second argument is an integer array B represents the profit obtained after buying the grocery items.



Output Format
Return an integer denoting the maximum profit you can earn.




*/



Java
public class Solution {
    public int solve(int[] A, int[] B) {
        // Initialize variables
        int mod = (int)1e9 + 7; // Modulo for preventing integer overflow
        int n = A.length; // Length of the arrays
        PriorityQueue<Integer> pending = new PriorityQueue<>(Collections.reverseOrder()); // Priority queue for pending tasks, sorted by profit in descending order
        ArrayList<pair> v = new ArrayList<>(); // Array of pairs representing tasks (deadline, profit)

        // Create pairs from A and B
        for (int i = 0; i < n; i++) {
            v.add(new pair(A[i], B[i]));
        }

        // Sort tasks by deadline in ascending order
        Collections.sort(v);

        // Initialize answer and current time
        int ans = 0;
        int tim = v.get(n-1).first - 1; // Start at the last deadline minus 1

        // Iterate through tasks in descending order of deadline
        for (int i = n - 1; i >= 0; i--) {
            // Process pending tasks until the current time is before the task's deadline
            while (tim >= v.get(i).first && pending.size() > 0) {
                tim--; // Decrement time
                ans = (ans + pending.poll()) % mod; // Add profit of highest-profit pending task to answer
            }

            // If there are no pending tasks, set the current time to the task's deadline minus 1
            if (pending.size() == 0) {
                tim = v.get(i).first - 1;
            }

            // Add the current task to the pending queue
            pending.add(v.get(i).second);
        }

        // Process any remaining pending tasks
        while (tim >= 0 && pending.size() > 0) {
            tim--;
            ans = (ans + pending.poll()) % mod;
        }

        return ans;
    }

    class pair implements Comparable<pair> {
        int first; // Deadline
        int second; // Profit

        public pair(int a, int b) {
            this.first = a;
            this.second = b;
        }

        public int compareTo(pair b) {
            // Compare by deadline in descending order, then by profit in ascending order
            if (this.first == b.first) {
                return -(b.second - this.second);
            } else {
                return -(b.first - this.first);
            }
        }
    }
}

---

Python

import heapq

class Solution:
    # @param A : list of integers
    # @param B : list of integers
    # @return an integer
    def solve(self, A, B):
        n = len(A)
        v = []
        for i in range(0, n):
            v.append((A[i], B[i]))

        v.sort()
        curTime = 0
        i = 0
        pq = []

        while(i < n):
            # if we can buy the ith car
            if(v[i][0] > curTime):
                heapq.heappush(pq, v[i][1])
                curTime += 1
            else:
                min_profit = heapq.heappop(pq)
                # reomve the already buy car giving minimum profit
                if(min_profit < v[i][1]):
                    heapq.heappush(pq, v[i][1])
                else:
                    heapq.heappush(pq, min_profit)
            i += 1

        ans = 0
        Mod = 1000000007
        while(len(pq) != 0):
            ans += heapq.heappop(pq)
            ans %= Mod

        return ans


----

Time and space complexity 

Time Complexity:

Sorting: The v.sort() operation sorts the list of pairs based on their deadlines. The time complexity of sorting depends on the algorithm used. In Python, the default sorting algorithm is Timsort, which has a time complexity of O(n log n) in the average and worst cases.

Iterating over Tasks: The while (i < n) loop iterates over each task. This loop runs for n iterations.

Priority Queue Operations:

heapq.heappush is used to add elements to the priority queue, which has a time complexity of O(log n).
heapq.heappop is used to remove the minimum element from the priority queue, which also has a time complexity of O(log n).
The worst-case scenario is when all tasks can be bought, and the priority queue grows to its maximum size of n. In this case, the total time complexity for priority queue operations is O(n log n).
Overall Time Complexity:

The dominant time complexity is from the sorting and priority queue operations. Therefore, the overall time complexity of the code is O(n log n).

Space Complexity:

v List: The v list stores pairs of deadlines and profits. The space complexity of this list is O(n), as it stores n elements.

Priority Queue: The priority queue stores the profits of tasks that can be bought. In the worst case, the priority queue can contain up to n elements. The space complexity of a heap is O(n).

Summary Space Complexity:

The overall space complexity is O(n), as the space used by the v list and the priority queue is proportional to the number of tasks.
