Array 3 pointers

Problem Description
You are given 3 sorted arrays A, B and C.
Find i, j, k such that : max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i])) is minimized.
Return the minimum max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i])).


Problem Constraints
1 <= len(A), len(B), len(c) <= 106
0 <= A[i], B[i], C[i] <= 107


Input Format
First argument is an integer array A.
Second argument is an integer array B.
Third argument is an integer array C.


Output Format
Return an single integer denoting the minimum max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i])).


Example Input
Input 1:
 A = [1, 4, 10]
 B = [2, 15, 20]
 C = [10, 12]
Input 2:
 A = [3, 5, 6]
 B = [2]
 C = [3, 4]


Example Output
Output 1:
 5
Output 2:
 1









public class Solution {
    /**
     * Finds the minimum value of max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i]))
     * by traversing through the sorted arrays A, B, and C.
     *
     * @param A Array of integers (sorted)
     * @param B Array of integers (sorted)
     * @param C Array of integers (sorted)
     * @return Minimum value of the maximum distance
     */
    public int minimize(int[] A, int[] B, int[] C) {
        int i = 0, j = 0, k = 0;
        int minMaxDistance = Integer.MAX_VALUE;  // Start with the maximum possible integer value
        
        // Traverse through the arrays using the three pointers
        while (i < A.length && j < B.length && k < C.length) {
            // Get current values from each array
            int a = A[i];
            int b = B[j];
            int c = C[k];
            
            // Compute the current maximum distance among the three pairs
            int currentMax = Math.max(Math.abs(a - b), Math.max(Math.abs(b - c), Math.abs(c - a)));
            
            // Update the minimum of the maximum distances found
            minMaxDistance = Math.min(minMaxDistance, currentMax);
            
            // Move the pointer pointing to the smallest value to try to reduce the maximum distance
            if (a <= b && a <= c) {
                i++;
            } else if (b <= a && b <= c) {
                j++;
            } else {
                k++;
            }
        }
        
        return minMaxDistance;
    }
    
}


class Solution:
    # @param A : tuple of integers
    # @param B : tuple of integers
    # @param C : tuple of integers
    # @return an integer
    def minimize(self, A, B, C):
        # Convert tuples to lists for easier manipulation
        A = list(A)
        B = list(B)
        C = list(C)
        
        # Initialize pointers for each array
        i, j, k = 0, 0, 0
        min_max_distance = float('inf')  # Start with infinity as the minimum
        
        # Traverse through the arrays using the three pointers
        while i < len(A) and j < len(B) and k < len(C):
            # Get current values from each array
            a, b, c = A[i], B[j], C[k]
            
            # Compute the current maximum distance among the three pairs
            current_max = max(abs(a - b), abs(b - c), abs(c - a))
            # Update the minimum of the maximum distances found
            min_max_distance = min(min_max_distance, current_max)
            
            # Move the pointer pointing to the smallest value to try to reduce the maximum distance
            if a <= b and a <= c:
                i += 1
            elif b <= a and b <= c:
                j += 1
            else:
                k += 1
        
        return min_max_distance



The given code effectively finds the minimum value of the maximum distance among the three pairs formed by elements from the sorted arrays A, B, and C. It uses a three-pointer approach to efficiently traverse the arrays and update the minimum maximum distance.
Time Complexity:
	• The time complexity is O(n + m + k), where n, m, and k are the lengths of arrays A, B, and C, respectively.
	• The outer while loop iterates at most n + m + k times, as one of the pointers is incremented in each iteration.
	• The operations within the loop, such as calculating maximum distances and updating the minimum, are constant-time operations.
Space Complexity:
	• The space complexity is O(1), as the code only uses constant extra space for variables.
	• No additional data structures or recursive calls are used, so the space usage remains constant.
In summary, the code has a time complexity of O(n + m + k) and a space complexity of O(1). This is an efficient solution for the given problem, as it avoids unnecessary computations and utilizes the sorted nature of the arrays to minimize the number of iterations.
