/*N children are standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum number of candies you must give? */

Python code
def candy(ratings):
  """Distributes candies to children based on their ratings.

  Args:
    ratings: A list of integers representing the ratings of each child.

  Returns:
    The minimum number of candies needed to distribute.
  """

  n = len(ratings)
  candies = [1] * n  # Initialize with 1 candy for each child

  # First pass: Assign more candies to children with higher ratings on the left
  for i in range(1, n):
    if ratings[i] > ratings[i - 1]:
      candies[i] = candies[i - 1] + 1

  # Second pass: Assign more candies to children with higher ratings on the right
  for i in range(n - 2, -1, -1):
    if ratings[i] > ratings[i + 1]:
      candies[i] = max(candies[i], candies[i + 1] + 1)

  return sum(candies)

# Example usage
ratings = [1, 0, 2]
result = candy(ratings)
print(result)  # Output: 5

version 2
class Solution:
    # @param A : list of integers
    # @return an integer
    def candy(self, A):
        n = len(A)
        if n == 0:
            return 0
        candies = [1] * n
        # Left to Right Pass
        for i in range(1, n):
            if A[i] > A[i - 1]:
                candies[i] = candies[i - 1] + 1
        # Right to Left Pass
        for i in range(n - 2, -1, -1):
            if A[i] > A[i + 1]:
                candies[i] = max(candies[i], candies[i + 1] + 1)
        return sum(candies)

Java code 
public class Solution {
    public int candy(int[] A) {

         int n = A.length;
        if (n == 0) {
            return 0;
        }
        int[] candies = new int[n];
        Arrays.fill(candies, 1);

        // Left to Right Pass
        for (int i = 1; i < n; i++) {
            if (A[i] > A[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }

        // Right to Left Pass
        for (int i = n - 2; i >= 0; i--) {
            if (A[i] > A[i + 1]) {
                candies[i] = Math.max(candies[i], candies[i + 1] + 1);
            }
        }

        int totalCandies = 0;
        for (int candy : candies) {
            totalCandies += candy;
        }
        return totalCandies;
    }
}


Explanation:
................
Initialization: Creates a list candies with 1 candy for each child.
First Pass:
Iterates from the second child (index 1) to the last.
Compares the current child's rating with the previous child's rating.
If the current child's rating is higher, increases their candy count by 1.
Second Pass:
Iterates from the second-to-last child (index n-2) to the first.
Compares the current child's rating with the next child's rating.
If the current child's rating is higher, updates their candy count to the maximum of their current count and the next child's count plus 1.
Return: Returns the sum of all candy counts.

Time and space complexity
--------------------------
Time complexity: O(n)

The code involves two loops, each iterating through the ratings array once.
The operations within each loop are constant time.
Therefore, the overall time complexity is linear, O(n).
Space complexity: O(n)

The code creates a new list candies to store the candy distribution for each child.
The size of this list is directly proportional to the number of children, n.
Therefore, the space complexity is also linear, O(n).
