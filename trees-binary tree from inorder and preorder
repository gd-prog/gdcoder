Binary Tree From Inorder And Preorder

Problem Description
Given preorder and inorder traversal of a tree, construct the binary tree.
NOTE: You may assume that duplicates do not exist in the tree.


Problem Constraints
1 <= number of nodes <= 105


Input Format
First argument is an integer array A denoting the preorder traversal of the tree.
Second argument is an integer array B denoting the inorder traversal of the tree.


Output Format
Return the root node of the binary tree.


Example Input
Input 1:
 A = [1, 2, 3]
 B = [2, 1, 3]
Input 2:
 A = [1, 6, 2, 3]
 B = [6, 1, 3, 2]


Example Output
Output 1:
   1
  / \
 2   3
Output 2:
   1  
  / \
 6   2
    /
   3


Example Explanation
Explanation 1:
 Create the binary tree and return the root node of the tree.



/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] A, int[] B) {
        if (A == null || A.length == 0 || B == null || B.length == 0) {
            return null;
        }
        return buildTreeHelper(A, 0, A.length - 1, B, 0, B.length - 1);
    }
    private TreeNode buildTreeHelper(int[] A, int preStart, int preEnd, int[] B, int inStart, int inEnd) {
        if (preStart > preEnd || inStart > inEnd) {
            return null;
        }
        // Root is the first element in preorder traversal
        int rootVal = A[preStart];
        TreeNode root = new TreeNode(rootVal);
        // Find the index of the root in inorder traversal
        int rootIndex = inStart;
        while (rootIndex <= inEnd && B[rootIndex] != rootVal) {
            rootIndex++;
        }
        // Length of left subtree based on inorder (elements before root)
        int leftSubtreeSize = rootIndex - inStart;
        // Construct left and right subtrees recursively
        root.left = buildTreeHelper(A, preStart + 1, preStart + leftSubtreeSize, B, inStart, rootIndex - 1);
        root.right = buildTreeHelper(A, preStart + leftSubtreeSize + 1, preEnd, B, rootIndex + 1, inEnd);
        return root;
    }
}

---

# Definition for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # @param A : list of integers (preorder traversal)
    # @param B : list of integers (inorder traversal)
    # @return the root node of the tree
    def buildTree(self, A, B):
        if not A or not B:
            return None
        return self.buildTreeHelper(A, 0, len(A) - 1, B, 0, len(B) - 1)
    
    def buildTreeHelper(self, A, preStart, preEnd, B, inStart, inEnd):
        if preStart > preEnd or inStart > inEnd:
            return None
        
        # Root is the first element in preorder traversal
        rootVal = A[preStart]
        root = TreeNode(rootVal)
        
        # Find the index of the root in inorder traversal
        rootIndex = inStart
        while rootIndex <= inEnd and B[rootIndex] != rootVal:
            rootIndex += 1
        
        # Length of left subtree based on inorder (elements before root)
        leftSubtreeSize = rootIndex - inStart
        
        # Construct left and right subtrees recursively
        root.left = self.buildTreeHelper(A, preStart + 1, preStart + leftSubtreeSize, B, inStart, rootIndex - 1)
        root.right = self.buildTreeHelper(A, preStart + leftSubtreeSize + 1, preEnd, B, rootIndex + 1, inEnd)
        
        return root


---

The space complexity of the provided Python code for building a binary tree from preorder and inorder traversals is O(N), where N is the number of nodes in the tree. This is because the recursive buildTreeHelper function creates a new TreeNode object for each node in the tree, and the maximum depth of the recursion stack is also O(N) in the worst case (a skewed tree).
The time complexity is also O(N). The buildTreeHelper function iterates through the inorder array once to find the root index, and then recursively builds the left and right subtrees. The total time spent in each level of recursion is proportional to the number of nodes at that level, so the overall time complexity is O(N).

