Infix to Postfix


Problem Description
Given string A denoting an infix expression. Convert the infix expression into a postfix expression.
String A consists of ^, /, *, +, -, (, ) and lowercase English alphabets where lowercase English alphabets are operands and ^, /, *, +, - are operators.
Find and return the postfix expression of A.
NOTE:
	• ^ has the highest precedence.
	• / and * have equal precedence but greater than + and -.
	• + and - have equal precedence and lowest precedence among given operators.


Problem Constraints
1 <= length of the string <= 500000


Input Format
The only argument given is string A.


Output Format
Return a string denoting the postfix conversion of A.


Example Input
Input 1:
 A = "x^y/(a*z)+b"
Input 2:
 A = "a+b*(c^d-e)^(f+g*h)-i"


Example Output
Output 1:
 "xy^az*/b+"
Output 2:
 "abcd^e-fgh*+^*+i-"


Example Explanation
Explanation 1:
 Ouput dentotes the postfix expression of the given input.



public class Solution {
//  This class defines a method to convert an infix expression to a postfix expression.
  public String solve(String A) {
//    Converts an infix expression to a postfix expression.
//    Args:
//        A: The infix expression string.
//    Returns:
//        The postfix expression string.
    Map<Character, Integer> precedence = new HashMap<>();
    precedence.put('^', 3);
    precedence.put('*', 2);
    precedence.put('/', 2);
    precedence.put('+', 1);
    precedence.put('-', 1);
    Stack<Character> stack = new Stack<>();
    StringBuilder postfix = new StringBuilder();
    for (char ch : A.toCharArray()) {
      if (Character.isLetter(ch)) {
        postfix.append(ch);  // Append operands directly
      } else if (ch == '(') {
        stack.push(ch);  // Push opening parenthesis
      } else if (ch == ')') {
        while (!stack.isEmpty() && stack.peek() != '(') {
          postfix.append(stack.pop());  // Pop operators until encountering opening parenthesis
        }
        stack.pop();  // Pop the opening parenthesis
      } else {
        // Operator handling
        while (!stack.isEmpty() && precedence.get(stack.peek()) >= precedence.get(ch)) {
          postfix.append(stack.pop());  // Pop operators with higher or equal precedence
        }
        stack.push(ch);  // Push current operator
      }
    }
    // Pop remaining operators from the stack
    while (!stack.isEmpty()) {
      postfix.append(stack.pop());
    }
    return postfix.toString();
  }
}

---


class Solution:
    def solve(self, A):
        """
        Converts an infix expression to a postfix expression.
        Args:
            A: The infix expression string.
        Returns:
            The postfix expression string.
        """
        stack = []  # Initialize a stack to store operators
        postfix = []  # Initialize a list to store the postfix expression
        precedence = {
            "^": 3,
            "/": 2,
            "*": 2,
            "+": 1,
            "-": 1
        }
        for char in A:
            if char.isalpha():  # If the character is an operand
                postfix.append(char)
            elif char == "(":  # If the character is a left parenthesis
                stack.append(char)
            elif char == ")":  # If the character is a right parenthesis
                while stack and stack[-1] != "(":
                    postfix.append(stack.pop())
                stack.pop()  # Remove the opening parenthesis
            else:  # If the character is an operator
                while stack and precedence.get(char, 0) <= precedence.get(stack[-1], 0):
                    postfix.append(stack.pop())
                stack.append(char)
        while stack:
            postfix.append(stack.pop())
        return "".join(postfix)


----

Time Complexity Analysis
The code iterates through each character in the input expression once. The operations within the loop, like stack push, pop, character comparison, and precedence checks, are constant-time operations. Therefore, the overall time complexity is O(n), where n is the length of the input expression.
Space Complexity Analysis
The primary data structures used are a stack for operators and a list for the postfix expression. In the worst case, the stack might need to store all operators, and the list might need to store all characters in the expression. However, for well-formed infix expressions, the stack size is typically limited. Therefore, the space complexity is also O(n) in general, but it can be lower in practice for balanced expressions.
