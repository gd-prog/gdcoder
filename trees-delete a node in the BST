Delete a node in BST

Given a Binary Search Tree(BST) A. If there is a node with value B present in the tree delete it and return the tree.

Note - If there are multiple options, always replace a node by its in-order predecessor


Problem Constraints
2 <= No. of nodes in BST <= 105
1 <= value of nodes <= 109
Each node has a unique value


Input Format
The first argument is the root node of a Binary Search Tree A.
The second argument is the value B.


Output Format
Delete the given node if found and return the root of the BST.


/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {
    public TreeNode solve(TreeNode A, int B) {
        if(A==null){
            return A;
        }
        // Case 1: If B is less than current node value, go to the left subtree
        if (B < A.val) {
            A.left = solve(A.left, B);
        }
        // Case 2: If B is greater than current node value, go to the right subtree
        else if (B > A.val) {
            A.right = solve(A.right, B);
        }
        // Case 3: B is equal to current node value, delete this node
        else {
            // Case 3.1: Node has no children (leaf node)
            if (A.left == null && A.right == null) {
                return null;
            }
            // Case 3.2: Node has only one child
            else if (A.left == null) {
                return A.right;
            } else if (A.right == null) {
                return A.left;
            }
            // Case 3.3: Node has two children (replace with in-order predecessor)
            else {
                TreeNode predecessor = findPredecessor(A.left);
                A.val = predecessor.val;
                A.left = solve(A.left, predecessor.val);
            }
        }
        return A;
    }
    // Helper function to find the in-order predecessor (rightmost node in left subtree)
    private TreeNode findPredecessor(TreeNode node) {
        TreeNode current = node;
        while (current.right != null) {
            current = current.right;
        }
        return current;
    }
}
----


# Definition for a binary tree node
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
class Solution:
    # @param A : root node of tree
    # @param B : integer
    # @return the root node in the tree
    def solve(self, A, B):
        """
        Deletes a node with the given key from the BST.
        Args:
            A (TreeNode): The root node of the BST.
            B (int): The value of the node to be deleted.
        Returns:
            TreeNode: The root node of the modified BST.
        """
        if A is None:
            return None
        if B < A.val:
            A.left = self.solve(A.left, B)
        elif B > A.val:
            A.right = self.solve(A.right, B)
        else:
            # Node to be deleted has no children
            if A.left is None and A.right is None:
                return None
            # Node to be deleted has only one child
            if A.left is None:
                return A.right
            if A.right is None:
                return A.left
            # Node to be deleted has two children
            # Find the in-order predecessor
            predecessor = A.left
            while predecessor.right:
                predecessor = predecessor.right
            # Replace the node to be deleted with its in-order predecessor
            A.val = predecessor.val
            A.left = self.solve(A.left, predecessor.val)
        return A
----
The given code is a recursive function to delete a node with the given key from a Binary Search Tree (BST).
Time Complexity:
	• Best case: O(log n), when the tree is balanced and the node to be deleted is found quickly.
	• Average case: O(log n), assuming the tree is reasonably balanced.
	• Worst case: O(n), when the tree is skewed and the node to be deleted is at the deepest level.
The time complexity depends on the height of the tree. In the best case, the height is logarithmic in the number of nodes, leading to a logarithmic time complexity. In the worst case, the height is equal to the number of nodes, resulting in a linear time complexity.

Space Complexity:
	• Best case: O(log n), when the tree is balanced and the recursive call stack is shallow.
	• Worst case: O(n), when the tree is skewed and the recursive call stack is deep.
The space complexity depends on the depth of the recursion. In the best case, the depth is logarithmic in the number of nodes, leading to a logarithmic space complexity. In the worst case, the depth is equal to the height of the tree, resulting in a linear space complexity.
In summary, the time and space complexity of the code are both O(log n) in the best and average cases, and O(n) in the worst case. The actual performance depends on the structure of the BST and the location of the node to be deleted.
