K reverse linked list


Problem Description
Given a singly linked list A and an integer B, reverse the nodes of the list B at a time and return the modified linked list.


Problem Constraints
1 <= |A| <= 103
B always divides A


Input Format
The first argument of input contains a pointer to the head of the linked list.
The second arugment of input contains the integer, B.


Output Format
Return a pointer to the head of the modified linked list.


Example Input
Input 1:
 A = [1, 2, 3, 4, 5, 6]
 B = 2
Input 2:
 A = [1, 2, 3, 4, 5, 6]
 B = 3


Example Output
Output 1:
 [2, 1, 4, 3, 6, 5]
Output 2:
 [3, 2, 1, 6, 5, 4]


Example Explanation
Explanation 1:
 For the first example, the list can be reversed in groups of 2.
    [[1, 2], [3, 4], [5, 6]]
 After reversing the K-linked list
    [[2, 1], [4, 3], [6, 5]]
Explanation 2:
 For the second example, the list can be reversed in groups of 3.
    [[1, 2, 3], [4, 5, 6]]
 After reversing the K-linked list
    [[3, 2, 1], [6, 5, 4]]



/**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode A, int B) {
        ListNode current=A;
        ListNode aNext=null;
        ListNode previous=null;
        int count=0;
        while(current!=null && count< B){
            aNext=current.next;
            current.next=previous;
            previous=current;
            current=aNext;
            count++;
        }
        if(aNext!=null){
            A.next=reverseList(aNext,B);
        }
        return previous;
    }
}

---


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

def reverse(A):
    if A.next == None:
        return A
    nxt = A.next
    A.next = None
    rvrsed = reverse(nxt)
    nxt.next = A
    return rvrsed

class Solution:
    # @param A : head node of linked list
    # @param B : integer
    # @return the head node in the linked list
    def reverseList(self, A, B):
        reversedFirst = A
        for i in range(1, B):
            reversedFirst = reversedFirst.next
        prev = ListNode(0)
        prev.next = A
        last = prev
        first = ListNode(0)
        while last.next:
            # take B consecutive nodes and reverse them
            for i in range(1, B + 1):
                last = last.next
            first = prev.next
            prev.next = None
            nxt = last.next
            last.next = None
            reverse(first)
            prev.next = last
            first.next = nxt
            prev = last = first
        return reversedFirst

----
Time Complexity:
	• Worst-case: O(N)
	• Average-case: O(N)
Explanation:
The time complexity is dominated by the nested loop that iterates through the linked list to reverse groups of nodes. In the worst case, the entire list is processed in groups of size B, leading to:
	• Outer loop: Executes N // B times (assuming N is a multiple of B)
	• Inner loop (within the reverse function): Executes B times for each group reversal
Therefore, the total number of iterations scales linearly with the list size N.
Space Complexity:
	• Worst-case: O(1) (Iterative Approach)
	• Worst-case: O(N) (Recursive Approach)
Explanation:
The iterative approach (reverse function) primarily uses constant extra space for temporary variables like nxt, rvrsed, and pointers during manipulation. These variables do not grow with the input size, hence the constant space complexity.
However, the recursive approach (reverseList) implicitly uses the call stack for function calls. In the worst-case scenario (when the entire list is reversed), the call stack depth can grow up to N (one for each node), leading to linear space complexity.
Breakdown for the provided code:
	1. reverse function (Iterative): O(1) space complexity as discussed above.
	2. reverseList function:
		○ Inner loop: O(1) space for temporary variables.
		○ Call stack (worst-case): O(N) space due to recursive calls.
Overall:
	• If you prioritize space efficiency, the iterative approach of the reverse function is preferred (O(1) space).
	• If readability or recursion is more important, the recursive approach within reverseList might be considered, but be aware of potentially higher space usage (O(N) worst-case).
Key points to remember:
	• Time complexity primarily depends on the number of iterations through the linked list (O(N)).
	• Space complexity can differ between iterative and recursive approaches:
		○ Iterative: O(1)
		○ Recursive (worst-case): O(N) for call stack

