
/* Matrix median
Problem Description
Given a matrix of integers A of size N x M in which each row is sorted.

Find and return the overall median of matrix A.

NOTE: No extra memory is allowed.

NOTE: Rows are numbered from top to bottom and columns are numbered from left to right.



Problem Constraints
1 <= N, M <= 10^5

1 <= N*M <= 10^6

1 <= A[i] <= 10^9

N*M is odd



Input Format
The first and only argument given is the integer matrix A.



Output Format
Return the overall median of matrix A.

*/





Java

public class Solution {
    public int findMedian(int[][] A) {
        int n = A.length;  // Number of rows
        int m = A[0].length; // Number of columns
        // Remarks:
        // - Initialize search range for the median (potential candidate): l = 1, r = maximum element
        int l = 1, r = 1000000000;
        // - Calculate the required number of elements less than or equal to the median: req
        int req = (n * m) / 2 + 1; // For odd total elements, middle element is median
        // - Pre-compute the maximum element in the matrix for efficiency (avoid redundant calculations)
        int maxElement = A[0][m - 1];
        for (int row = 1; row < n; row++) {
            maxElement = Math.max(maxElement, A[row][m - 1]);
        }
        r = Math.max(r, maxElement);  // Update search range with the actual maximum
        // - Initialize `ans` to store the final median
        int ans = -1;
        // - Binary search loop to find the median
        while (l <= r) {
            int mid = l + (r - l) / 2; // Calculate middle value
            // - Count elements less than or equal to `mid` using binary search
            int cnt = 0;
            for (int[] row : A) {
                cnt += count(row, mid);
            }
            // - Update search range based on the count
            if (cnt >= req) {
                ans = mid; // Potential median found
                r = mid - 1; // Search for lower median candidates
            } else {
                l = mid + 1; // Search for higher median candidates
            }
        }
        return ans; // Return the median
    }
    static int count(int[] a, int x) {
        int i = 0, j = a.length - 1;
        // - Binary search to find the first element greater than `x`
        int ans = -1;
        while (i <= j) {
            int m = (i + j) / 2;
            if (a[m] > x) {
                ans = m;
                j = m - 1;
            } else {
                i = m + 1;
            }
        }
        // - Return the index (number of elements less than or equal to `x`)
        if (ans == -1) {
            return a.length; // All elements are less than or equal to `x`
        }
        return ans;
    }
}








Python


class Solution:
    def findMedian(self, A):
        n = len(A)  # Number of rows
        m = len(A[0])  # Number of columns
        
        # Initialize search range for the median
        l = 1
        r = 1000000000
        
        # Calculate the required number of elements less than or equal to the median
        req = (n * m) // 2 + 1
        
        # Pre-compute the maximum element in the matrix
        maxElement = A[0][m - 1]
        for row in range(1, n):
            maxElement = max(maxElement, A[row][m - 1])
        
        r = max(r, maxElement)  # Update search range with the actual maximum
        
        # Initialize `ans` to store the final median
        ans = -1
        
        # Binary search loop to find the median
        while l <= r:
            mid = l + (r - l) // 2  # Calculate middle value
            
            # Count elements less than or equal to `mid` using binary search
            cnt = 0
            for row in A:
                cnt += self.count(row, mid)
            
            # Update search range based on the count
            if cnt >= req:
                ans = mid  # Potential median found
                r = mid - 1  # Search for lower median candidates
            else:
                l = mid + 1  # Search for higher median candidates
        
        return ans  # Return the median
    
    def count(self, a, x):
        i, j = 0, len(a) - 1
        ans = -1
        
        # Binary search to find the first element greater than `x`
        while i <= j:
            m = (i + j) // 2
            if a[m] > x:
                ans = m
                j = m - 1
            else:
                i = m + 1
        
        # Return the index (number of elements less than or equal to `x`)
        if ans == -1:
            return len(a)  # All elements are less than or equal to `x`
        return ans


-----

Time Complexity:

Outer loop: Iterates n times (number of rows).
Inner loop: Iterates m times (number of columns) for each row.
Binary search (count function): Iterates log(m) times for each row.
Overall: O(n * m * log(m)).
Space Complexity:

Auxiliary space: The count function uses a constant amount of space for its variables.
Overall: O(1).
Explanation:

The outer loop iterates over each row of the matrix.
The inner loop iterates over each column of the current row.
The count function performs a binary search to find the number of elements in the current row that are less than or equal to the current mid value. This binary search has a time complexity of O(log(m)).
Since the outer loop iterates n times and the inner loop iterates m times, the overall time complexity is O(n * m * log(m)).
The code does not allocate any significant amount of additional memory, so the space complexity is O(1).
Additional Notes:

The code could be optimized by pre-computing the maximum element in each row to avoid redundant calculations in the binary search.
The code could also be optimized by using a more efficient data structure for the matrix, such as a sorted array or a heap, if the matrix is already sorted or can be sorted efficiently.
