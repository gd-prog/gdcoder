/* Rotated Binary array search

Given a sorted array of integers A of size N and an integer B, 
where array A is rotated at some pivot unknown beforehand.

For example, the array [0, 1, 2, 4, 5, 6, 7] might become [4, 5, 6, 7, 0, 1, 2].

Your task is to search for the target value B in the array. If found, return its index; otherwise, return -1.

You can assume that no duplicates exist in the array.

NOTE: You are expected to solve this problem with a time complexity of O(log(N)).


Problem Constraints
1 <= N <= 1000000
1 <= A[i] <= 109
All elements in A are Distinct.


Input Format
The First argument given is the integer array A.
The Second argument given is the integer B.


Output Format
Return index of B in array A, otherwise return -1

*/





Java

public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public int search(final int[] A, int B) {
        int start=0;
   int end=A.length-1;
   while(start<=end){
       int midIdx=(end-start)/2 + start;
       if(A[midIdx]==B){
       return midIdx;
       }
   else if(A[midIdx]>=A[start]){
           if(B<=A[midIdx]&&B>=A[start])
           end=midIdx-1;
           else
           start=midIdx+1;
       }
   else if(B>=A[midIdx] && B<=A[end]){
       start=midIdx+1;
       }
   else {
       end=midIdx-1;
   }
   }      
   return -1;
    }
}


----
Python

class Solution:
    # @param A : tuple of integers
    # @param B : integer
    # @return an integer
    def search(self, A, B):
        """
        Searches for the target element B in a rotated sorted array A.

        Args:
            A: A tuple of integers representing the rotated sorted array.
            B: The target element to search for.

        Returns:
            The index of the target element in the array if found, otherwise -1.
        """

        start = 0
        end = len(A) - 1

        while start <= end:
            mid_idx = (end - start) // 2 + start

            if A[mid_idx] == B:
                return mid_idx  # Target element found
            elif A[mid_idx] >= A[start]:
                # If the middle element is greater than or equal to the first element,
                # the left half is sorted in ascending order.
                if B <= A[mid_idx] and B >= A[start]:
                    # If the target element is within the range of the sorted left half,
                    # search in the left half.
                    end = mid_idx - 1
                else:
                    # Otherwise, search in the right half.
                    start = mid_idx + 1
            elif B >= A[mid_idx] and B <= A[end]:
                # If the middle element is less than the first element,
                # the right half is sorted in ascending order.
                # If the target element is within the range of the sorted right half,
                # search in the right half.
                start = mid_idx + 1
            else:
                # Otherwise, search in the left half.
                end = mid_idx - 1

        return -1  # Target element not found

---

Time Complexity:

Binary search loop: Iterates log(n) times, where n is the length of the array A.
Inside the loop, comparisons and arithmetic operations are performed in constant time.
Therefore, the overall time complexity of the search function is O(log(n)).

Space Complexity:

The search function uses constant space for its variables.
Therefore, the space complexity of the search function is O(1).
In summary, the time complexity of the code is O(log(n)) and the space complexity is O(1).








