Sum Binary tree or not

Problem Description
Given a binary tree. Check whether the given tree is a Sum-binary Tree or not.
Sum-binary Tree is a Binary Tree where the value of a every node is equal to sum of the nodes present in its left subtree and right subtree.
An empty tree is Sum-binary Tree and sum of an empty tree can be considered as 0. A leaf node is also considered as SumTree.
Return 1 if it sum-binary tree else return 0.


Problem Constraints
1 <= length of the array <= 100000
0 <= node values <= 50


Input Format
The only argument given is the root node of tree A.


Output Format
Return 1 if it is sum-binary tree else return 0.



A simple solution is to check for every node is their sub-tree sum is equal to value of that node.
But it will take O(n2)
An efficient approach is to store sum of subtree at the node, so we don’t need to calculate it again and again.
1) If the node is a leaf node then sum of subtree rooted with this node is equal to value of this node.
2) If the node is not a leaf node then sum of subtree rooted with this node is twice the value of this node (Assuming that the tree rooted with this node is SumTree).
If all nodes are sumTree return 1 else return 0.



Java

/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {
    public int solve(TreeNode A) {
        return checksumtree(A);
    }
    public static int isLeaf(TreeNode node) {
        if (node == null)
            return 0;
        if (node.left == null && node.right == null)
            return 1;
        return 0;
    }
    public static int isSumTree(TreeNode node) {
        int ls, rs;
        if (node == null || isLeaf(node) == 1)
            return 1;
        if (isSumTree(node.left) == 1 && isSumTree(node.right) == 1) {
            if (node.left == null)
                ls = 0;
            else if (isLeaf(node.left) == 1)
                ls = node.left.val;
            else
                ls = 2 * (node.left.val);
            if (node.right == null)
                rs = 0;
            else if (isLeaf(node.right) == 1)
                rs = node.right.val;
            else
                rs = 2 * (node.right.val);
            if (node.val == ls + rs)
                return 1;
            else
                return 0;
        }
        return 0;
    }
    public static int checksumtree(TreeNode root) {
        if (isSumTree(root) == 1)
            return 1;
        return 0;
    }
}

Python


# Definition for a binary tree node
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # @param A : root node of tree
    # @return an integer
    def solve(self, A):
        def isLeaf(node):
            """Checks if a node is a leaf node."""
            if node is None:
                return 0
            if node.left is None and node.right is None:
                return 1
            return 0
        def isSumTree(node):
            """Checks if a subtree rooted at node is a Sum-Binary Tree."""
            if node is None or isLeaf(node) == 1:
                return 1  # Empty tree or leaf node is a Sum-Binary Tree
            if isSumTree(node.left) == 1 and isSumTree(node.right) == 1:
                # If left and right subtrees are Sum-Binary Trees, calculate their sums
                ls = 0 if node.left is None else (node.left.val if isLeaf(node.left) == 1 else 2 * node.left.val)
                rs = 0 if node.right is None else (node.right.val if isLeaf(node.right) == 1 else 2 * node.right.val)
                return 1 if node.val == ls + rs else 0  # Check if current node's value is the sum
            return 0
        def checksumtree(root):
            """Checks if the entire tree is a Sum-Binary Tree."""
            return 1 if isSumTree(root) == 1 else 0
        return checksumtree(A)


Time complexity

The provided Python code recursively traverses the binary tree to check if it's a Sum-Binary Tree. The isSumTree function is called for each node in the tree, leading to a time complexity of O(n), where n is the number of nodes.
	• isLeaf: This function has a constant time complexity of O(1) as it only checks the presence of left and right children.
	• isSumTree: The recursive calls to isSumTree for left and right subtrees contribute to the O(n) time complexity. The calculations of ls and rs are also constant time operations.
	• checksumtree: This function simply calls isSumTree once, so it has a time complexity of O(n).
Therefore, the overall time complexity of the solve function is O(n).

Space complexity

The space complexity is primarily due to the recursive calls in the isSumTree function. In the worst case, the recursion stack can have a depth equal to the height of the tree. For a balanced binary tree, the height is approximately log(n), so the space complexity is O(log n). However, for a skewed tree, the height can be n, leading to a worst-case space complexity of O(n).
In summary, the time complexity of the code is O(n), and the space complexity is O(log n) in the best case (balanced tree) and O(n) in the worst case (skewed tree).
