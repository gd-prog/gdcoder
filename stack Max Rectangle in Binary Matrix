Problem:

Given a 2-D binary matrix A of size N x M filled with 0's and 1's, find the largest rectangle containing only ones and return its area.

Java
public class Solution {

    public int maximalRectangle(int[][] A) {
        int rows = A.length;
        if (rows == 0) return 0; // Handle empty matrix

        int cols = A[0].length;
        if (cols == 0) return 0; // Handle empty matrix

        // Create a DP matrix to store heights of consecutive 1's
        int[][] dp = new int[rows][cols];

        // Initialize the first row of dp (heights for the first row)
        for (int j = 0; j < cols; j++) {
            dp[0][j] = A[0][j];
        }

        int maxArea = 0;

        // Calculate the maximum area for the first row (treated as a histogram)
        maxArea = calculateMaxAreaInHistogram(dp[0]);

        // Iterate through the remaining rows
        for (int i = 1; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (A[i][j] == 0) {
                    dp[i][j] = 0; // Update height to 0 if current element is 0
                } else {
                    dp[i][j] = dp[i - 1][j] + 1; // Build height based on previous row
                }
            }

            // Find the maximum area in the current row using dp (treated as a histogram)
            maxArea = Math.max(maxArea, calculateMaxAreaInHistogram(dp[i]));
        }

        return maxArea;
    }

    // Function to find the largest rectangle area in a histogram
    private static int calculateMaxAreaInHistogram(int[] heights) {
        int maxArea = 0;
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < heights.length; i++) {
            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {
                int currentHeight = heights[stack.pop()];
                int width = i - (stack.isEmpty() ? 0 : stack.peek() + 1);
                maxArea = Math.max(maxArea, currentHeight * width);
            }
            stack.push(i);
        }

        // Handle remaining elements in the stack (no smaller element on the right)
        while (!stack.isEmpty()) {
            int currentHeight = heights[stack.pop()];
            int width = heights.length - (stack.isEmpty() ? 0 : stack.peek() + 1);
            maxArea = Math.max(maxArea, currentHeight * width);
        }

        return maxArea;
    }
}

The code leverages Dynamic Programming (DP) with a stack to efficiently find the maximum area of a rectangle formed by consecutive 1's in a binary matrix. Here's a breakdown of the key points:

DP Matrix (dp): It stores the heights of consecutive 1's for each element based on the previous row. This avoids redundant calculations.
Histogram Analogy: Each row in the dp matrix can be treated as a histogram where the bars represent the heights. We use a stack to find the largest rectangle area within this histogram.
Stack Usage: The stack keeps track of indices with non-decreasing heights. When a smaller height is encountered, elements from the stack are popped, and the area is calculated considering the popped height and the current index. This ensures we find the maximum rectangle ending at the current element.
Final Maximum Area: The function iterates through all rows, updates the dp matrix, and finds the maximum area in each row using the calculateMaxAreaInHistogram function. The overall maximum area is kept track of and returned.

Python
from collections import deque

class Solution:
    """
    This class contains a solution for finding the maximal rectangle area in a binary matrix.
    """

    def maximalRectangle(self, A):
        """
        This function finds the maximal rectangle area in a binary matrix.

        Args:
            A: The input binary matrix (2D list of 0s and 1s).

        Returns:
            The maximum area of a rectangle containing only 1s in the matrix.
        """

        rows = len(A)
        if not rows:
            return 0  # Handle empty matrix

        cols = len(A[0])
        if not cols:
            return 0  # Handle empty matrix

        # Create a DP matrix to store heights of consecutive 1's for each element (based on the previous row)
        dp = [[0] * cols for _ in range(rows)]

        # Initialize the first row of dp (heights for the first row)
        for j in range(cols):
            dp[0][j] = A[0][j]

        max_area = 0

        # Calculate maximum area for the first row (treated as a histogram)
        max_area = self.calculate_max_area_in_histogram(dp[0])

        # Iterate through the remaining rows
        for i in range(1, rows):
            for j in range(cols):
                # If current element is 0, reset height in dp
                if A[i][j] == 0:
                    dp[i][j] = 0
                # Otherwise, add 1 to the previous height (building on consecutive 1's)
                else:
                    dp[i][j] = dp[i - 1][j] + 1

            # Find the maximum area in the current row using dp (treated as a histogram)
            max_area = max(max_area, self.calculate_max_area_in_histogram(dp[i]))

        return max_area

    def calculate_max_area_in_histogram(self, heights):
        """
        This function finds the largest rectangle area in a histogram.

        Args:
            heights: The input list representing the heights of the histogram.

        Returns:
            The maximum area of a rectangle within the histogram.
        """

        max_area = 0
        stack = deque()

        for i in range(len(heights)):
            while stack and heights[i] < heights[stack[-1]]:
                current_height = heights[stack.pop()]
                # Width is calculated considering elements to the left (i) and right (stack[-1] if not empty)
                width = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, current_height * width)
            stack.append(i)

        # Handle remaining elements in the stack (no smaller element on the right)
        while stack:
            current_height = heights[stack.pop()]
            width = len(heights) if not stack else len(heights) - stack[-1] - 1
            max_area = max(max_area, current_height * width)

        return max_area


 let's perform a dry run of the code for a sample input matrix A = [ [1, 1, 0, 1], [1, 1, 1, 1], [1, 1, 0, 0] ]:

Step 1: Initialization

rows = 3, cols = 4
dp:
[[1, 1, 0, 1],
 [2, 2, 1, 1],
 [3, 2, 0, 0]]
Step 2: Calculate Maximum Area for Each Row

Row 1:

Call calculate_max_area_in_histogram(dp[0])
Stack: [0] (initially empty)
Process dp[0]:
i = 0: heights[i] = 1, stack remains empty.
i = 1: heights[i] = 1, stack remains [0].
i = 2: heights[i] = 0, nothing to pop from the stack. dp[0][2] = 0.
i = 3: heights[i] = 1, stack remains [0].
After processing, stack: [0], max_area = 1 * 4 (considering the entire row).
Row 2:

Call calculate_max_area_in_histogram(dp[1])
Stack: [0] (from previous row)
Process dp[1]:
i = 0: heights[i] = 2, stack remains [0].
i = 1: heights[i] = 2, stack remains [0].
i = 2: heights[i] = 1, pop [0] from the stack. width = 2, max_area = max(1 * 4, 2 * 2) = 4.
i = 3: heights[i] = 1, stack: [2].
After processing, stack: [2], max_area = 4.
Row 3:

Call calculate_max_area_in_histogram(dp[2])
Stack: [2] (from previous row)
Process dp[2]:
i = 0: heights[i] = 3, stack remains [2].
i = 1: heights[i] = 2, pop [2] from the stack. width = 1, max_area = max(4, 3 * 1) = 4. (Note: No change in overall max_area)
i = 2: heights[i] = 0, nothing to pop from the stack. dp[2][2] = 0.
i = 3: heights[i] = 0, nothing to pop from the stack. dp[2][3] = 0.
After processing, stack: [], max_area = 4.
Step 3: Final Result

After iterating through all rows, the final max_area remains 4, which is the maximum rectangle area found in the matrix.

Explanation:

The dp matrix keeps track of the heights of consecutive 1's based on the previous row.
The calculate_max_area_in_histogram function leverages the stack to efficiently find the maximum rectangle area within a row treated as a histogram.
The overall maximum area is tracked throughout the process and represents the largest rectangle containing only 1s in the matrix.

code utilizes Dynamic Programming (DP) with a stack to achieve a time complexity of O(n * m) and a space complexity of O(m), where:

n is the number of rows in the matrix.
m is the number of columns in the matrix.
Here's a breakdown of the complexity:

Time Complexity (O(n * m)):

DP Matrix Construction (O(n * m)): Iterating through the matrix to fill the dp takes O(n * m) time.
Histogram Calculations (O(n * m)):
In the worst case, for each row (n times), the calculate_max_area_in_histogram function might be called n times (due to pushing and popping elements from the stack). However, the total number of stack operations (push and pop) is still proportional to the number of elements in each row (m) because each element is processed at most once. Therefore, the overall time complexity for histogram calculations remains O(n * m).
Space Complexity (O(m)):

The dp matrix stores heights for each element, requiring O(n * m) space. However, since m (number of columns) is typically smaller or comparable to n (number of rows) in most practical scenarios, we can consider the space complexity to be dominated by the number of columns (O(m)).
The stack used in calculate_max_area_in_histogram holds indices in the worst case up to the number of columns (m) in each iteration. Since the stack size is bounded by m, the space complexity is O(m).
