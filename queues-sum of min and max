Sum of min and max


Problem Description
Given an array A of both positive and negative integers.
Your task is to compute the sum of minimum and maximum elements of all sub-array of size B.
NOTE: Since the answer can be very large, you are required to return the sum modulo 109 + 7.


Problem Constraints
1 <= size of array A <= 105
-109 <= A[i] <= 109
1 <= B <= size of array


Input Format
The first argument denotes the integer array A.
The second argument denotes the value B


Output Format
Return an integer that denotes the required value.


Example Input
Input 1:
 A = [2, 5, -1, 7, -3, -1, -2]
 B = 4
Input 2:
 A = [2, -1, 3]
 B = 2


Example Output
Output 1:
 18
Output 2:
 3


Example Explanation
Explanation 1:
 Subarrays of size 4 are : 
    [2, 5, -1, 7],   min + max = -1 + 7 = 6
    [5, -1, 7, -3],  min + max = -3 + 7 = 4      
    [-1, 7, -3, -1], min + max = -3 + 7 = 4
    [7, -3, -1, -2], min + max = -3 + 7 = 4   
    Sum of all min & max = 6 + 4 + 4 + 4 = 18 
Explanation 2:
 Subarrays of size 2 are : 
    [2, -1],   min + max = -1 + 2 = 1
    [-1, 3],   min + max = -1 + 3 = 2
    Sum of all min & max = 1 + 2 = 3 



public class Solution {
    public int solve(int[] A, int B) {
        int mod = 1000 * 1000 * 1000 + 7;
        // maintain increasing order of values from front to rear
        Deque < Integer > minn = new ArrayDeque < Integer > ();
        // maintain decreasing order of values from front to rear
        Deque < Integer > maxx = new ArrayDeque < Integer > ();
        int i = 0;
        // Process first window of size B
        for (; i < B; i++) {
            // Remove all previous greater elements that are useless.
            while (minn.size() > 0 && A[minn.getLast()] >= A[i]) {
                minn.removeLast();
            }
            // Remove all previous smaller that are elements are useless.
            while (maxx.size() > 0 && A[maxx.getLast()] <= A[i]) {
                maxx.removeLast();
            }
            // Add current element at rear of both deque
            minn.addLast(i);
            maxx.addLast(i);
        }
        long sum = A[minn.getFirst()] + A[maxx.getFirst()];
        while (i < A.length) {
            // remove all previous greater element that are useless
            while (minn.size() > 0 && A[minn.getLast()] >= A[i]) {
                minn.removeLast();
            }
            // remove all previous smaller that are elements are useless
            while (maxx.size() > 0 && A[maxx.getLast()] <= A[i]) {
                maxx.removeLast();
            }
            // Add current element at rear of both deque
            minn.addLast(i);
            maxx.addLast(i);
            // Remove all elements which are out of this window
            while (i - minn.getFirst() >= B) {
                minn.removeFirst();
            }
            while (i - maxx.getFirst() >= B) {
                maxx.removeFirst();
            }
            // Element at the front of the deque are the largest and smallest  element of previous window respectively
            sum += A[maxx.getFirst()] + A[minn.getFirst()];
            sum %= mod;
            i++;
        }
        sum += mod;
        sum %= mod;
        return (int) sum;
    }
}

----


from collections import deque
class Solution:
    # @param A : list of integers
    # @param B : integer
    # @return an integer
    def solve(self, A, B):
        mod = 1000000007
        minn = deque()  # Maintain increasing order of values from front to rear
        maxx = deque()  # Maintain decreasing order of values from front to rear
        i = 0
        # Process first window of size B
        for i in range(B):
            # Remove all previous greater elements that are useless.
            while minn and A[minn[-1]] >= A[i]:
                minn.pop()
            # Remove all previous smaller that are elements are useless.
            while maxx and A[maxx[-1]] <= A[i]:
                maxx.pop()
            # Add current element at rear of both deque
            minn.append(i)
            maxx.append(i)
        sum = A[minn[0]] + A[maxx[0]]
        
        for i in range(B, len(A)):
            # Remove all previous greater element that are useless
            while minn and A[minn[-1]] >= A[i]:
                minn.pop()
            # Remove all previous smaller that are elements are useless
            while maxx and A[maxx[-1]] <= A[i]:
                maxx.pop()
            # Add current element at rear of both deque
            minn.append(i)
            maxx.append(i)
            # Remove all elements which are out of this window
            while i - minn[0] >= B:
                minn.popleft()
            while i - maxx[0] >= B:
                maxx.popleft()
            # Element at the front of the deque are the largest and smallest element of previous window respectively
            sum += A[maxx[0]] + A[minn[0]]
            sum %= mod
            i += 1
        sum += mod
        sum %= mod
        return sum


----

The time and space complexity of the provided code for the solve function are as follows:
Time Complexity:
	• Outer loop: Iterates over each element in the input array A, except for the first B elements. This takes O(N - B) time, where N is the length of A.
	• Inner loops: The inner loops remove elements from the minn and maxx deques until they contain only elements that are within the current window. In the worst case, all elements in the previous window might need to be removed, leading to O(B) operations for each iteration of the outer loop.
	• Deque operations: Adding and removing elements from a deque are constant-time operations (O(1)).
	• Other operations: The remaining operations, such as calculating the sum and taking the modulo, are also constant-time.
Therefore, the overall time complexity of the solve function is O((N - B) * B). However, since B is a constant value, we can simplify this to O(N).
Space Complexity:
	• Deques: The minn and maxx deques store at most B elements at any given time. Therefore, their space complexity is O(B), which is constant since B is a constant value.
	• Other variables: The sum variable and the index i require constant space.
Therefore, the overall space complexity of the solve function is O(1).

