
Check for BST with one child

Problem Description
Given preorder traversal of a binary tree, check if it is possible that it is also a preorder traversal of a Binary Search Tree (BST), where each internal node (non-leaf nodes) have exactly one child.


Problem Constraints
1 <= number of nodes <= 100000

Input Format
First and only argument is an integer array denoting the preorder traversal of binary tree.

Output Format
Return a string "YES" if true else "NO".

Example Input
Input 1:
 A : [4, 10, 5, 8]
Input 2:
 A : [1, 5, 6, 4]


Example Output
Output 1:
 "YES"
Output 2:
 "NO"


Example Explanation
Explanation 1:
 The possible BST is:
            4
             \
             10
             /
             5
              \
              8
Explanation 2:
 There is no possible BST which have the above preorder traversal.



public class Solution {
    public String solve(int[] A) {
           int n = A.length;
        if (n <= 2) {
            return "YES";
        }
        int mn = Math.min(A[n - 1], A[n - 2]);
        int mx = Math.max(A[n - 1], A[n - 2]);
        for (int i = n - 3; i >= 0; i--) {
            // Each node must be either smaller than the min node or larger than the max node
            if (A[i] > mn && A[i] < mx) {
                return "NO";
            }
            mn = Math.min(mn, A[i]);
            mx = Math.max(mx, A[i]);
        }
        return "YES";
    }
}

---

class Solution:
    def solve(self, A):
        """
        Checks if the given array forms a valid binary search tree (BST).
        Args:
            A (list[int]): The input array.
        Returns:
            str: "YES" if the array can form a BST, "NO" otherwise.
        This function iterates through the array from the end, maintaining the minimum and maximum values seen so far.
        If any element is not within the valid range (either less than the minimum or greater than the maximum),
        it means the array cannot form a BST.
        """
        n = len(A)
        if n <= 2:
            # Arrays of length 1 or 2 are always valid BSTs
            return "YES"
        # Initialize minimum and maximum values
        mn = min(A[-1], A[-2])
        mx = max(A[-1], A[-2])
        for i in range(n - 3, -1, -1):
            # Check if the current element is within the valid range
            if mn < A[i] < mx:
                return "NO"
            # Update minimum and maximum values
            mn = min(mn, A[i])
            mx = max(mx, A[i])
        return "YES"

---
The time complexity of the provided code to check if a given array forms a valid binary search tree (BST) is O(n), where n is the length of the array. This is because the code iterates through the array once, performing constant-time operations at each iteration to check if the current element is within the valid range and update the minimum and maximum values.
The space complexity of the code is O(1), as it only uses a constant amount of additional space to store the variables n, mn, mx, and the loop index i. There are no data structures or recursive calls that would significantly increase the space usage.

