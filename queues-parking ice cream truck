Parking Ice Cream Truck

Problem Description
Imagine you're an ice cream truck driver in a beachside town. The beach is divided into several sections, and each section has varying numbers of beachgoers wanting ice cream given by the array of integers A.

For simplicity, let's say the beach is divided into 8 sections. One day, you note down the number of potential customers in each section: [5, 12, 3, 4, 8, 10, 2, 7]. This means there are 5 people in the first section, 12 in the second, and so on.

You can only stop your truck in B consecutive sections at a time because of parking restrictions. To maximize sales, you want to park where the most customers are clustered together.

For all B consecutive sections, identify the busiest stretch to park your ice cream truck and serve the most customers. Return an array C, where C[i] is the busiest section in each of the B consecutive sections. Refer to the given example for clarity.
NOTE: If B > length of the array, return 1 element with the max of the array.


Problem Constraints
1 <= |A|, B <= 106


Input Format
The first argument given is the integer array A.
The second argument given is the integer B.


Output Format
Return an array C, where C[i] is the maximum value from A[i] to A[i+B-1].


Example Input
Input 1:
 A = [1, 3, -1, -3, 5, 3, 6, 7]
 B = 3
Input 2:
 A = [1, 2, 3, 4, 2, 7, 1, 3, 6]
 B = 6


Example Output
Output 1:
 [3, 3, 5, 5, 6, 7]
Output 2:
 [7, 7, 7, 7]


Example Explanation
Explanation 1:
 Window position     | Max
 --------------------|-------
 [1 3 -1] -3 5 3 6 7 | 3
 1 [3 -1 -3] 5 3 6 7 | 3
 1 3 [-1 -3 5] 3 6 7 | 5
 1 3 -1 [-3 5 3] 6 7 | 5
 1 3 -1 -3 [5 3 6] 7 | 6
 1 3 -1 -3 5 [3 6 7] | 7
Explanation 2:
 Window position     | Max
 --------------------|-------
 [1 2 3 4 2 7] 1 3 6 | 7
 1 [2 3 4 2 7 1] 3 6 | 7
 1 2 [3 4 2 7 1 3] 6 | 7
 1 2 3 [4 2 7 1 3 6] | 7



public class Solution {
  // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
  public int[] slidingMaximum(final int[] A, int B) {
    if (B > A.length) {
      return new int[]{findMax(A)}; // Return max of the array if B is bigger
    }
    int[] result = new int[A.length - B + 1];
    Deque<Integer> deque = new LinkedList<>();
    // Maintain a deque with indices of elements with decreasing values
    for (int i = 0; i < A.length; i++) {
      // Remove irrelevant elements from the deque (smaller or equal values)
      while (!deque.isEmpty() && A[deque.peekLast()] <= A[i]) {
        deque.pollLast();
      }
      // Add the current index to the deque
      deque.offerLast(i);
      // Check if the first element is outside the current window
      if (i - deque.peekFirst() >= B) {
        deque.pollFirst();
      }
      // Store the maximum element in the current window
      if ( i >= B - 1){
      result[i - B + 1] = A[deque.peekFirst()];
      }
    }
    return result;
  }
  private static int findMax(int[] A) {
    int max = Integer.MIN_VALUE;
    for (int num : A) {
      max = Math.max(max, num);
    }
    return max;
  }
}


---
Python


from collections import deque
class Solution:
    # @param A : tuple of integers
    # @param B : integer
    # @return a list of integers
    def slidingMaximum(self, A, B):
        if B > len(A):
            return [max(A)]  # Return max of the array if B is bigger
        
        result = [0] * (len(A) - B + 1)
        q = deque()  # Maintain a deque with indices of elements with decreasing values
        for i in range(len(A)):
            # Remove indices of elements that are out of the current window
            while q and q[0] <= i - B:
                q.popleft()
            # Remove indices of elements that are smaller than the current element
            while q and A[q[-1]] <= A[i]:
                q.pop()
            # Add the current index to the deque
            q.append(i)
            # Store the maximum element in the current window
            if i >= B - 1:
                result[i - B + 1] = A[q[0]]
        return result



---

Time Complexity:
	• Outer loop: Iterates over each element in the input array A, taking O(N) time, where N is the length of A.
	• Inner loops: The inner loops remove elements from the deque until they contain only elements that are within the current window. In the worst case, all elements in the previous window might need to be removed, leading to O(B) operations for each iteration of the outer loop.
	• Deque operations: Adding and removing elements from a deque are constant-time operations (O(1)).
	• Other operations: The remaining operations, such as accessing the first element of the deque and storing the maximum element, are also constant-time.
Therefore, the overall time complexity of the slidingMaximum function is O(N * B). However, since B is a constant value, we can simplify this to O(N).
Space Complexity:
	• Deque: The deque stores at most B elements at any given time. Therefore, its space complexity is O(B), which is constant since B is a constant value.
	• Other variables: The result array and the index i require O(N) and O(1) space, respectively.
Therefore, the overall space complexity of the slidingMaximum function is O(N) due to the result array. The deque has a constant space complexity of O(B).
