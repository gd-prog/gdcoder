/*
Problem Description
Given a binary tree, return the inorder traversal of its nodes' values.



Problem Constraints
1 <= number of nodes <= 105



Input Format
First and only argument is root node of the binary tree, A.



Output Format
Return an integer array denoting the inorder traversal of the given binary tree.
*/
---
Java

/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *         val = x;
 *         left=null;
 *         right=null;
 *     }
 * }
 */
public class Solution {
    public int[] inorderTraversal(TreeNode A) {
        if (A == null) {
            return new int[0];
        }

        Stack<TreeNode> stack = new Stack<>();
        List<Integer> result = new ArrayList<>();
        TreeNode current = A;

        while (current != null || !stack.isEmpty()) {
            // Reach the leftmost node of the current node
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            // Current must be null at this point
            current = stack.pop();
            result.add(current.val);

            // Visit the right subtree
            current = current.right;
        }

        // Convert the result list to an array
        int[] ans = new int[result.size()];
        for (int i = 0; i < result.size(); i++) {
            ans[i] = result.get(i);
        }

        return ans;
    }
}

---
Python

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = None

class Solution:
    # @param A : root node of tree
    # @return a list of integers
    def inorderTraversal(self, A):
        """
        Performs inorder traversal of a binary tree.

        Args:
            A: The root node of the binary tree.

        Returns:
            A list of integers representing the inorder traversal of the tree.
        """

        if not A:  # If the root is None, the tree is empty
            return []

        stack = []  # Create a stack to store nodes
        result = []  # Create a list to store the inorder traversal result
        current = A  # Initialize current node to the root

        while current or stack:  # Continue until current is None and stack is empty
            while current:  # Traverse to the leftmost node
                stack.append(current)
                current = current.left

            current = stack.pop()  # Pop the top node from the stack
            result.append(current.val)  # Add the node's value to the result list

            current = current.right  # Visit the right subtree

        return result

----
The time complexity of the inorderTraversal function is O(n), where n is the number of nodes in the binary tree. This is because each node is visited exactly once during the traversal, and the operations within the loops are constant time.

The space complexity is also O(n) in the worst case. This occurs when the tree is skewed to the left or right, as the stack can potentially store up to n nodes. In the best case, when the tree is balanced, the space complexity is O(log n), as the maximum depth of a balanced binary tree is log n.
