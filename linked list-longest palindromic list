Longest Palindromic list

Problem Description
Given a linked list of integers. Find and return the length of the longest palindrome list that exists in that linked list.
A palindrome list is a list that reads the same backward and forward.
Expected memory complexity : O(1)


Problem Constraints
1 <= length of the linked list <= 2000
1 <= Node value <= 100


Input Format
The only argument given is head pointer of the linked list.


Output Format
Return the length of the longest palindrome list.


Example Input
Input 1:
 2 -> 3 -> 3 -> 3
Input 2:
 2 -> 1 -> 2 -> 1 ->  2 -> 2 -> 1 -> 3 -> 2 -> 2


Example Output
Output 1:
 3
Output 2:
 5


Example Explanation
Explanation 1:
 3 -> 3 -> 3 is largest palindromic sublist
Explanation 2:
 2 -> 1 -> 2 -> 1 -> 2 is largest palindromic sublist.


/**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public int solve(ListNode A) {
        ListNode dummy = new ListNode(-1);
        ListNode cur = A, prev = dummy;
        int ans = 0;
        while (cur != null) {
            // Case 1: cur is a center node of palindrome of odd length
            ListNode prevItr = prev, nextItr = cur.next;
            int l = 1;
            while (prevItr != null && nextItr != null) {
                if (prevItr.val == nextItr.val) {
                    prevItr = prevItr.next;
                    nextItr = nextItr.next;
                    l++;
                } else break;
            }
            ans = Math.max(ans, l + l - 1);
            // Case 2: When palindrome length is even
            l = 0;
            prevItr = prev;
            nextItr = cur;
            while (prevItr != null && nextItr != null) {
                if (prevItr.val == nextItr.val) {
                    prevItr = prevItr.next;
                    nextItr = nextItr.next;
                    l++;
                } else break;
            }
            ans = Math.max(2 * l, ans);
            ListNode Next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = Next;
        }
        return ans;
    }
}
---

# Definition for singly-linked list.
# class ListNode:
#    def __init__(self, x):
#        self.val = x
#        self.next = None

class Solution:
    # @param A : head node of linked list
    # @return an integer
    def solve(self, A):
        def reverseList(head):
            prev = None
            while head:
                next_node = head.next
                head.next = prev
                prev = head
                head = next_node
            return prev

        dummy = ListNode(-1)
        cur = A
        prev = dummy
        ans = 0
        
        while cur:
            # Case 1: cur is the center node of a palindrome of odd length
            prev_itr = prev
            next_itr = cur.next
            length = 1
            
            while prev_itr and next_itr:
                if prev_itr.val == next_itr.val:
                    prev_itr = prev_itr.next
                    next_itr = next_itr.next
                    length += 1
                else:
                    break
            
            ans = max(ans, length + length - 1)
            
            # Case 2: When palindrome length is even
            length = 0
            prev_itr = prev
            next_itr = cur
            
            while prev_itr and next_itr:
                if prev_itr.val == next_itr.val:
                    prev_itr = prev_itr.next
                    next_itr = next_itr.next
                    length += 1
                else:
                    break
            
            ans = max(2 * length, ans)
            
            # Reversing the linked list up to the current node
            next_node = cur.next
            cur.next = prev
            prev = cur
            cur = next_node
        
        return ans

---
Time Complexity:
	• reverseList function: This helper function reverses a linked list in-place. It iterates through the list once, taking O(n) time where n is the number of nodes in the list. Since it modifies the original list and uses constant extra space for pointers, its space complexity is O(1).
	• Main loop: The main loop iterates through the original linked list once (while cur). Within the loop, there are two nested loops for handling odd and even-length palindromes. Each nested loop iterates at most n times until a mismatch is found. 
		○ Case 1 (odd length): O(n) time for the nested loop.
		○ Case 2 (even length): O(n) time for the nested loop.
	• Reversing up to current node: This operation reverses the previously processed part of the list. It iterates through the list once up to the current node, taking O(n) time.
Overall Time Complexity:
In the worst case, both Case 1 and Case 2 calculations could occur for each node in the list. Since each case has O(n) time complexity and the main loop iterates at most n times, the overall time complexity of the solve function is O(n^2).
Space Complexity:
	• The code uses a constant amount of extra space for the following: 
		○ dummy node
		○ Pointers (prev, prev_itr, next_itr, next_node)
	• No additional data structures are used that scale with the input size. Therefore, the space complexity is O(1).
In summary:
	• Time Complexity: O(n^2) in the worst case
	• Space Complexity: O(1)
