/*
Given an array A, find the next greater element G[i] for every element A[i] in the array.
The next greater element for an element A[i] is the first greater element on the right side of A[i] in the array, A.

More formally:

G[i] for an element A[i] = an element A[j] such that 
    j is minimum possible AND 
    j > i AND
    A[j] > A[i]
Elements for which no greater element exists, consider the next greater element as -1.



Problem Constraints
1 <= |A| <= 105

1 <= A[i] <= 107



Input Format
The first and the only argument of input contains the integer array, A.



Output Format
Return an integer array representing the next greater element for each index in A.






*/


Java

public class Solution {
    public int[] nextGreater(int[] A) {

        // Stack version to find the next greater element for each element in the array
        int n = A.length;
        int[] result = new int[n];
        Stack<Integer> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {
            // Pop elements from the stack that are less than or equal to the current element
            while (!stack.isEmpty() && stack.peek() <= A[i]) {
                stack.pop();
            }

            // If the stack is not empty, the top element is the next greater element
            if (!stack.isEmpty()) {
                result[i] = stack.peek();
            } else {
                // If the stack is empty, there is no next greater element
                result[i] = -1;
            }

            // Push the current element onto the stack
            stack.push(A[i]);
        }

        return result;
    }
}





----
Python

class Solution:
    # @param A : list of integers
    # @return a list of integers
    def nextGreater(self, A):
        """
        Finds the next greater element for each element in the given array.

        Args:
            A: The input array of integers.

        Returns:
            A list of integers, where each element represents the next greater element
            for the corresponding element in the input array. If there is no next
            greater element, -1 is returned.
        """

        n = len(A)
        result = [0] * n  # Initialize the result array
        stack = []  # Create an empty stack to store elements

        # Iterate through the array from right to left
        for i in range(n - 1, -1, -1):
            # Pop elements from the stack that are less than or equal to the current element
            while stack and stack[-1] <= A[i]:
                stack.pop()

            # If the stack is not empty, the top element is the next greater element
            if stack:
                result[i] = stack[-1]
            else:
                # If the stack is empty, there is no next greater element
                result[i] = -1

            # Push the current element onto the stack
            stack.append(A[i])

        return result

----

The time complexity of the given code is O(n), where n is the length of the input array A. This is because the outer loop iterates n times, and the inner loop is at most O(n) in the worst case (when the stack is empty and all elements need to be popped). However, in practice, the inner loop is often much faster than O(n) due to early termination.

The space complexity is also O(n) due to the stack. In the worst case, all elements of the array could be pushed onto the stack, resulting in a space complexity of O(n).
